# -*- coding: utf-8 -*-
import math
import re
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd

import dash
from dash import Dash, dcc, html, Input, Output, callback
import plotly.graph_objs as go

# ============================
# CONFIG ‚Äî modifie ici si besoin
# ============================
MATURITIES = ["2Y", "5Y", "10Y", "15Y", "20Y"]   # ajoute "30Y" si tu veux
PERIODS_PER_YEAR = 252                            # donn√©es quotidiennes
ROLLING_WINDOW_VOL = 252                          # vol toujours annualis√©e 1Y (calcul√©e avec window=252)
VOL_LABEL = "1Y"                                  # nommage des colonnes de vol
DEFAULT_VOL_RATIO_RANGE = (0.0, 10.0)             # slider vol ratio (step=0.5)

TAB_NOMINAL = "tab_nominal"
TAB_INFL = "tab_inflation"
TAB_BETA = "tab_beta"

# Optionnel: mapping codes -> noms lisibles
COUNTRY_NAME_MAP = {
    "FR": "France",
    "IT": "Italy",
    "DE": "Germany",
    "ES": "Spain",
    "PT": "Portugal",
    "GR": "Greece",
    "IE": "Ireland",
    "BE": "Belgium",
    "NL": "Netherlands",
    "AT": "Austria",
    "FI": "Finland",
}


# ============================
# 0) COLLECTE DES INPUTS DEPUIS TES VARIABLES GLOBALES
#    - trouve df_Swap et df_Inflation_Swap(s)
#    - construit countries √† partir de df_<CODE> (ex: df_FR, df_IT, ...)
# ============================
def _get_global_df(var_names: List[str]) -> Optional[pd.DataFrame]:
    g = globals()
    for name in var_names:
        if name in g and isinstance(g[name], pd.DataFrame):
            return g[name]
    return None

def collect_inputs_from_globals() -> Tuple[Dict[str, pd.DataFrame], pd.DataFrame, pd.DataFrame]:
    """
    D√©tecte: df_Swap, df_Inflation_Swap (ou df_Inflation_Swaps), et tous les df_<CODE> (pays).
    Retourne (countries, df_Swap, df_Inflation_Swap).
    Erreurs lev√©es si manquants.
    """
    swap = _get_global_df(["df_Swap"])
    infl = _get_global_df(["df_Inflation_Swap", "df_Inflation_Swaps"])
    if swap is None:
        raise ValueError("Missing required DataFrame: df_Swap")
    if infl is None:
        raise ValueError("Missing required DataFrame: df_Inflation_Swap (or df_Inflation_Swaps)")

    countries: Dict[str, pd.DataFrame] = {}
    for var, val in list(globals().items()):
        if not isinstance(val, pd.DataFrame):
            continue
        m = re.fullmatch(r"df_([A-Za-z]{2})", var)   # df_FR, df_IT, ...
        if m:
            code = m.group(1).upper()
            label = COUNTRY_NAME_MAP.get(code, code)
            countries[label] = val

    if not countries:
        raise ValueError("No country DataFrames found (expected variables like df_FR, df_IT, ...)")

    return countries, swap, infl


# ============================
# 1) HELPERS ‚Äî pr√©-traitements
# ============================
def ensure_datetime_index(df: pd.DataFrame) -> pd.DataFrame:
    if not isinstance(df.index, pd.DatetimeIndex):
        df = df.copy()
        df.index = pd.to_datetime(df.index)
    return df.sort_index()

def infer_prefix_from_columns(df: pd.DataFrame, maturities: List[str]) -> Optional[str]:
    for c in df.columns:
        for m in maturities:
            if c.endswith("_" + m):
                return c[: -len(m) - 1]
    return None

def list_existing_maturities(df: pd.DataFrame, prefix: str, maturities: List[str]) -> List[str]:
    return [m for m in maturities if f"{prefix}_{m}" in df.columns]

def convert_percent_to_bps(df: pd.DataFrame, prefix: str, maturities: List[str]) -> pd.DataFrame:
    out = df.copy()
    for m in list_existing_maturities(out, prefix, maturities):
        out[f"{prefix}_{m}_bps"] = pd.to_numeric(out[f"{prefix}_{m}"], errors="coerce") * 100.0  # 1% = 100 bps
    return out

def add_rolling_annualized_vol_bps(
    df: pd.DataFrame,
    prefix: str,
    maturities: List[str],
    window: int = ROLLING_WINDOW_VOL,      # 252
    periods_per_year: int = PERIODS_PER_YEAR,
    vol_label: str = VOL_LABEL,
) -> pd.DataFrame:
    """
    VOL annualis√©e (toujours) des variations journali√®res en bps:
      dx = diff(bps)
      vol = std(dx, rolling window) * sqrt(periods_per_year)
    """
    out = df.copy()
    for m in list_existing_maturities(out, prefix, maturities):
        bps_col = f"{prefix}_{m}_bps"
        if bps_col in out.columns:
            x = pd.to_numeric(out[bps_col], errors="coerce")
            dx = x.diff()
            vol = dx.rolling(window=window, min_periods=max(5, window // 4)).std() * math.sqrt(periods_per_year)
            out[f"{vol_label}_Vol_{prefix}_{m}"] = vol
    return out

def process_curve_df(
    df: pd.DataFrame,
    prefix: Optional[str],
    maturities: List[str],
    window: int = ROLLING_WINDOW_VOL,
    periods_per_year: int = PERIODS_PER_YEAR,
    vol_label: str = VOL_LABEL,
) -> Tuple[pd.DataFrame, str]:
    df = ensure_datetime_index(df)
    if prefix is None:
        prefix = infer_prefix_from_columns(df, maturities)
        if prefix is None:
            raise ValueError("Could not infer prefix from columns.")
    out = convert_percent_to_bps(df, prefix, maturities)
    out = add_rolling_annualized_vol_bps(out, prefix, maturities, window, periods_per_year, vol_label)
    return out, prefix

def add_diff_vs_swap(
    df_country: pd.DataFrame,
    country_prefix: str,
    df_swap: pd.DataFrame,
    swap_prefix: str,
    maturities: List[str],
) -> pd.DataFrame:
    out = df_country.copy()
    for m in list_existing_maturities(out, country_prefix, maturities):
        c_bps = f"{country_prefix}_{m}_bps"
        s_bps = f"{swap_prefix}_{m}_bps"
        if c_bps in out.columns and s_bps in df_swap.columns:
            out[f"diff_bps_{m}_{country_prefix}_Swap"] = out[c_bps] - df_swap[s_bps].reindex(out.index)
    return out

def rolling_corr(s1: pd.Series, s2: pd.Series, window: int) -> pd.Series:
    join = pd.concat([s1, s2], axis=1, join="inner").dropna()
    if join.empty:
        return pd.Series(dtype=float)
    r = join[s1.name].rolling(window=window, min_periods=max(5, window // 4)).corr(join[s2.name])
    return r


# ============================
# 2) PR√âPARATION GLOBALE (au d√©marrage)
# ============================
def prepare_all(
    countries: Dict[str, pd.DataFrame],
    df_Swap: pd.DataFrame,
    df_Inflation_Swap: pd.DataFrame,   # requis
    maturities: List[str] = MATURITIES,
    periods_per_year: int = PERIODS_PER_YEAR,
    window_vol: int = ROLLING_WINDOW_VOL,
    vol_label: str = VOL_LABEL,
) -> Tuple[Dict[str, pd.DataFrame], pd.DataFrame, pd.DataFrame, Dict[str, str], str, str]:
    # Swaps
    swap_proc, swap_prefix = process_curve_df(df_Swap, prefix=None, maturities=maturities,
                                              window=window_vol, periods_per_year=periods_per_year, vol_label=vol_label)
    # Inflation Swaps (requis)
    infl_proc, infl_prefix = process_curve_df(df_Inflation_Swap, prefix=None, maturities=maturities,
                                              window=window_vol, periods_per_year=periods_per_year, vol_label=vol_label)

    # Pays
    out_countries: Dict[str, pd.DataFrame] = {}
    used_prefix: Dict[str, str] = {}
    for cname, cdf in countries.items():
        c_proc, pfx = process_curve_df(cdf, prefix=None, maturities=maturities,
                                       window=window_vol, periods_per_year=periods_per_year, vol_label=vol_label)
        used_prefix[cname] = pfx
        c_proc = add_diff_vs_swap(c_proc, pfx, swap_proc, swap_prefix, maturities)
        out_countries[cname] = c_proc

    return out_countries, swap_proc, infl_proc, used_prefix, swap_prefix, infl_prefix


# ============================
# 3) VUE (pays+maturit√©) + figures
# ============================
def build_selection_df(country_name: str, maturity: str,
                       countries_proc: Dict[str, pd.DataFrame],
                       used_prefix: Dict[str, str],
                       swap_proc: pd.DataFrame,
                       swap_prefix: str) -> Tuple[Optional[pd.DataFrame], Optional[str]]:
    """Retourne (df, err_msg). Si err_msg non None -> afficher et ne rien tracer."""
    if country_name not in countries_proc:
        return None, f"No data found for {country_name} {maturity}"
    cdf = countries_proc[country_name]
    pfx = used_prefix[country_name]

    needed = [
        f"{pfx}_{maturity}", f"{pfx}_{maturity}_bps", f"{VOL_LABEL}_Vol_{pfx}_{maturity}",
        f"{swap_prefix}_{maturity}", f"{swap_prefix}_{maturity}_bps", f"{VOL_LABEL}_Vol_{swap_prefix}_{maturity}",
        f"diff_bps_{maturity}_{pfx}_Swap"
    ]
    have = set(cdf.columns).union(set(swap_proc.columns))
    if not set(needed).issubset(have):
        return None, f"No data found for {country_name} {maturity}"

    df = pd.DataFrame(index=cdf.index)
    mapping = {
        "it_level_pct": f"{pfx}_{maturity}",
        "it_bps": f"{pfx}_{maturity}_bps",
        "it_vol_bps": f"{VOL_LABEL}_Vol_{pfx}_{maturity}",
        "sw_level_pct": f"{swap_prefix}_{maturity}",
        "sw_bps": f"{swap_prefix}_{maturity}_bps",
        "sw_vol_bps": f"{VOL_LABEL}_Vol_{swap_prefix}_{maturity}",
        "diff_bps": f"diff_bps_{maturity}_{pfx}_Swap",
    }
    for alias, col in mapping.items():
        if col in cdf.columns:
            df[alias] = cdf[col]
        elif col in swap_proc.columns:
            df[alias] = swap_proc[col].reindex(df.index)
        else:
            df[alias] = np.nan

    df["vol_ratio"] = df["it_vol_bps"] / df["sw_vol_bps"]
    df.replace([np.inf, -np.inf], np.nan, inplace=True)  # robustesse division par 0
    df["diff_vol_bps"] = df["it_vol_bps"] - df["sw_vol_bps"]

    df.index = pd.to_datetime(df.index)
    df = df.sort_index()
    if df[["it_bps", "it_vol_bps", "sw_bps", "sw_vol_bps"]].dropna(how="any").empty:
        return None, f"No data found for {country_name} {maturity}"
    return df, None

def years_colors(index: pd.DatetimeIndex):
    years = index.year if len(index) else np.array([])
    return years, dict(colorscale="Viridis",
                       cmin=(years.min() if len(years) else 0),
                       cmax=(years.max() if len(years) else 1),
                       color=years)

def fig_scatter_xy(x, y, color_years, title, xlab, ylab):
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=x, y=y, mode="markers",
        marker=dict(size=6, **{k: v for k, v in color_years.items() if k not in ("cmin", "cmax")}),
        showlegend=False
    ))
    fig.update_layout(
        title=title,
        xaxis_title=xlab,
        yaxis_title=ylab,
        template="plotly_white",
        margin=dict(l=50, r=20, t=50, b=40),
    )
    return fig

def fig_timeseries_two(y1, y2, idx, name1, name2, title, ylab, secondary_y=False):
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=idx, y=y1, mode="lines", name=name1))
    if secondary_y:
        fig.add_trace(go.Scatter(x=idx, y=y2, mode="lines", name=name2, yaxis="y2"))
        fig.update_layout(
            yaxis=dict(title=ylab),
            yaxis2=dict(title=name2, overlaying="y", side="right", showgrid=False),
        )
    else:
        fig.add_trace(go.Scatter(x=idx, y=y2, mode="lines", name=name2))
        fig.update_layout(yaxis=dict(title=ylab))
    fig.update_layout(
        title=title,
        template="plotly_white",
        xaxis=dict(tickformat="%Y"),
        margin=dict(l=50, r=20, t=50, b=40),
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    )
    return fig

def fig_single_series(y, idx, title, ylab, name=None):
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=idx, y=y, mode="lines", name=name or y.name))
    fig.update_layout(
        title=title,
        xaxis=dict(tickformat="%Y"),
        yaxis=dict(title=ylab),
        template="plotly_white",
        margin=dict(l=50, r=20, t=50, b=40),
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    )
    return fig


# ============================
# 4) CONSTRUCTION DES DONN√âES & APP
# ============================
# 4.1 ‚Äî r√©cup√©rer tes DataFrames depuis les variables globales
countries_raw, df_Swap_raw, df_Infl_raw = collect_inputs_from_globals()

# 4.2 ‚Äî pr√©parer toutes les s√©ries (bps, vols annu 1Y, spreads)
countries_proc, swap_proc, infl_proc, used_prefix, SWAP_PREFIX, INFL_PREFIX = prepare_all(
    countries_raw, df_Swap_raw, df_Infl_raw
)

ALL_COUNTRIES = list(countries_proc.keys())
ALL_MATURITIES = MATURITIES[:]

# 4.3 ‚Äî Dash layout
app: Dash = dash.Dash(__name__)
app.title = "Rates Vol Dashboard"

def build_country_options():
    return [{"label": c, "value": c} for c in sorted(ALL_COUNTRIES)]

def build_maturity_options():
    return [{"label": m, "value": m} for m in ALL_MATURITIES]

app.layout = html.Div([
    html.H2("Rates Vol Dashboard"),
    html.Div([
        html.Div([
            html.Label("Maturity"),
            dcc.RadioItems(
                id="maturity",
                options=build_maturity_options(),
                value=("10Y" if "10Y" in ALL_MATURITIES else (ALL_MATURITIES[0] if ALL_MATURITIES else None)),
                inline=True
            ),
        ], style={"display": "inline-block", "marginRight": "32px"}),

        html.Div([
            html.Label("Country"),
            dcc.RadioItems(
                id="country",
                options=build_country_options(),
                value=(sorted(ALL_COUNTRIES)[0] if ALL_COUNTRIES else None),
                inline=True
            ),
        ], style={"display": "inline-block", "marginRight": "32px"}),

        html.Div([
            html.Label("Rolling Corr Window"),
            dcc.RadioItems(
                id="corr-window",
                options=[
                    {"label": "3M (63)", "value": 63},
                    {"label": "6M (126)", "value": 126},
                    {"label": "1Y (252)", "value": 252},
                ],
                value=252,
                inline=True
            ),
        ], style={"display": "inline-block"}),
    ], style={"marginBottom": "12px"}),

    html.Div([
        html.Label("Vol Ratio bounds"),
        dcc.RangeSlider(
            id="vol-ratio-bounds",
            min=0.0, max=10.0, step=0.5,
            allowCross=False,
            value=list(DEFAULT_VOL_RATIO_RANGE),
            marks={i: str(i) for i in range(0, 11, 1)}
        )
    ], style={"marginTop": "6px", "marginBottom": "16px"}),

    html.Div([
        html.Label("Beta bounds"),
        dcc.RangeSlider(
            id="beta-bounds",
            min=-4, max=10, step=0.5,
            allowCross=False,
            value=[-4, 10],
            marks={i: str(i) for i in range(-4, 11, 2)}
        )
    ], style={"marginTop": "0px", "marginBottom": "20px"}),

    html.Div(id="data-warning", style={"color": "crimson", "marginBottom": "10px"}),

    dcc.Tabs(id="active-tab", value=TAB_NOMINAL, children=[
        dcc.Tab(label="Vol Analysis vs Nominal Swaps", value=TAB_NOMINAL),
        dcc.Tab(label="Vol Analysis vs Inflation Swaps", value=TAB_INFL),
        dcc.Tab(label="Beta Analysis", value=TAB_BETA),
    ]),

    html.Div(id="tab-content", style={"marginTop": "12px"}),
])

# Sections
def nominal_section_layout():
    return html.Div([
        html.H4("1) Country Vol vs Level (heatmap-style scatter)"),
        dcc.Graph(id="fig1_it", config={"displaylogo": False}),
        html.H4("2) Swap Vol vs Level (heatmap-style scatter)"),
        dcc.Graph(id="fig2_swap", config={"displaylogo": False}),
        html.H4("3) Vol Ratio vs Diff (bps) ‚Äî filtered by slider"),
        dcc.Graph(id="fig3_ratio_vs_diff", config={"displaylogo": False}),
        html.H4("4) Diff Vol (bps) vs Diff (bps)"),
        dcc.Graph(id="fig4_diffvol_vs_diff", config={"displaylogo": False}),
        html.H4("5) Rolling correlation(Vol Country, Vol Swap) + Spread (bps, right axis)"),
        dcc.Graph(id="fig5_corr_spread", config={"displaylogo": False}),
        html.H4("6) Time series: Country vs Swap Vol (bps)"),
        dcc.Graph(id="fig6_vol_ts", config={"displaylogo": False}),
        html.H4("7) Time series: Country vs Swap Level (bps)"),
        dcc.Graph(id="fig7_level_ts", config={"displaylogo": False}),
        html.H4("8) Time series: Vol Ratio (respects slider bounds)"),
        dcc.Graph(id="fig8_ratio_ts", config={"displaylogo": False}),
    ])

def placeholder_section_layout(title: str):
    return html.Div([
        html.Div(f"{title} ‚Äî coming soon üë∑‚Äç‚ôÇÔ∏è", style={"fontStyle": "italic", "color": "#777", "padding": "12px"}),
    ])

@callback(
    Output("tab-content", "children"),
    Input("active-tab", "value"),
)
def render_tab_content(active_tab):
    if active_tab == TAB_NOMINAL:
        return nominal_section_layout()
    elif active_tab == TAB_INFL:
        return placeholder_section_layout("Vol Analysis vs Inflation Swaps")
    elif active_tab == TAB_BETA:
        return placeholder_section_layout("Beta Analysis")
    return html.Div()

# Callback principal ‚Äî onglet Nominal
@callback(
    Output("data-warning", "children"),
    Output("fig1_it", "figure"),
    Output("fig2_swap", "figure"),
    Output("fig3_ratio_vs_diff", "figure"),
    Output("fig4_diffvol_vs_diff", "figure"),
    Output("fig5_corr_spread", "figure"),
    Output("fig6_vol_ts", "figure"),
    Output("fig7_level_ts", "figure"),
    Output("fig8_ratio_ts", "figure"),
    Input("active-tab", "value"),
    Input("country", "value"),
    Input("maturity", "value"),
    Input("vol-ratio-bounds", "value"),
    Input("corr-window", "value"),
)
def update_nominal_figs(active_tab, country_name, maturity, ratio_bounds, corr_win):
    empty = go.Figure()
    if active_tab != TAB_NOMINAL:
        return ("", empty, empty, empty, empty, empty, empty, empty, empty)

    if country_name is None or maturity is None:
        return ("Select a country and a maturity.", empty, empty, empty, empty, empty, empty, empty, empty)

    # build df pour ce pays/matu
    df, err = build_selection_df(country_name, maturity, countries_proc, used_prefix, swap_proc, SWAP_PREFIX)
    if err:
        return (err, empty, empty, empty, empty, empty, empty, empty, empty)
    if df is None or df.empty:
        return (f"No data found for {country_name} {maturity}", empty, empty, empty, empty, empty, empty, empty, empty)

    # core data requis
    core_cols = ["it_bps", "it_vol_bps", "sw_bps", "sw_vol_bps"]
    df = df.dropna(subset=core_cols).copy()
    if df.empty:
        return (f"No data found for {country_name} {maturity}", empty, empty, empty, empty, empty, empty, empty, empty)

    years, color_kwargs = years_colors(df.index)

    # 1) Country heatmap-like
    fig1 = fig_scatter_xy(
        x=df["it_bps"], y=df["it_vol_bps"], color_years=color_kwargs,
        title=f"{country_name} {maturity}: Vol({VOL_LABEL}) vs Level",
        xlab=f"{country_name} {maturity} (bps)", ylab=f"Vol {VOL_LABEL} (bps)"
    )

    # 2) Swap heatmap-like
    fig2 = fig_scatter_xy(
        x=df["sw_bps"], y=df["sw_vol_bps"], color_years=color_kwargs,
        title=f"Swap {maturity}: Vol({VOL_LABEL}) vs Level",
        xlab=f"Swap {maturity} (bps)", ylab=f"Vol {VOL_LABEL} (bps)"
    )

    # 3) Vol Ratio vs diff (filtr√© slider)
    lo, hi = ratio_bounds if ratio_bounds and len(ratio_bounds) == 2 else DEFAULT_VOL_RATIO_RANGE
    df["vol_ratio"] = df["vol_ratio"].replace([np.inf, -np.inf], np.nan)
    mask = (df["vol_ratio"].between(lo, hi, inclusive="both")) & df["diff_bps"].notna()
    df_ratio = df.loc[mask]
    fig3 = fig_scatter_xy(
        x=df_ratio["diff_bps"], y=df_ratio["vol_ratio"], color_years=years_colors(df_ratio.index)[1],
        title=f"Vol Ratio vs Diff (bps) ‚Äî bounds [{lo:.1f}, {hi:.1f}]",
        xlab=f"Diff level ( {country_name} {maturity} ‚àí Swap {maturity} ) [bps]",
        ylab="Vol Ratio = Country vol / Swap vol"
    )

    # 4) diff_vol_bps vs diff_bps
    df_diffv = df.dropna(subset=["diff_bps", "diff_vol_bps"])
    fig4 = fig_scatter_xy(
        x=df_diffv["diff_bps"], y=df_diffv["diff_vol_bps"], color_years=years_colors(df_diffv.index)[1],
        title="Diff vol (bps) vs Diff level (bps)",
        xlab=f"Diff level ( {country_name} {maturity} ‚àí Swap {maturity} ) [bps]",
        ylab=f"Diff vol ( Country ‚àí Swap ) [bps]"
    )

    # 5) Rolling corr (fen√™tre dynamique) + spread (axe droit)
    corr = rolling_corr(
        df["it_vol_bps"].rename("it_vol"),
        df["sw_vol_bps"].rename("sw_vol"),
        window=int(corr_win) if corr_win else 252
    )
    spread = df["diff_bps"]
    both = pd.concat([corr.rename("corr"), spread.rename("spread")], axis=1, join="inner").dropna()
    fig5 = fig_timeseries_two(
        y1=both["corr"], y2=both["spread"], idx=both.index,
        name1=f"Rolling Corr ({int(corr_win)}d)",
        name2="Spread (bps)",
        title=f"Rolling Corr Country vs Swap Vols + Spread ({country_name} {maturity})",
        ylab="Correlation",
        secondary_y=True
    )

    # 6) Time series vols
    fig6 = fig_timeseries_two(
        y1=df["it_vol_bps"], y2=df["sw_vol_bps"], idx=df.index,
        name1=f"{country_name} {maturity} vol (bps)",
        name2=f"Swap {maturity} vol (bps)",
        title=f"Vols {VOL_LABEL} (bps)",
        ylab="bps",
        secondary_y=False
    )

    # 7) Time series levels
    fig7 = fig_timeseries_two(
        y1=df["it_bps"], y2=df["sw_bps"], idx=df.index,
        name1=f"{country_name} {maturity} (bps)",
        name2=f"Swap {maturity} (bps)",
        title="Levels (bps)",
        ylab="bps",
        secondary_y=False
    )

    # 8) Time series vol ratio
    fig8 = fig_single_series(
        y=df_ratio["vol_ratio"], idx=df_ratio.index,
        title=f"Vol Ratio time series ‚Äî bounds [{lo:.1f}, {hi:.1f}]",
        ylab="Vol Ratio",
        name="Vol Ratio"
    )

    return ("", fig1, fig2, fig3, fig4, fig5, fig6, fig7, fig8)


# ============================
# 5) MAIN ‚Äî lancement
# ============================
if __name__ == "__main__":
    import webbrowser, socket
    def get_local_ip():
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
        except Exception:
            ip = "127.0.0.1"
        finally:
            s.close()
        return ip

    host, port = "0.0.0.0", 8051
    local_ip = get_local_ip()
    print("\n================= SHARE THIS =================")
    print(f"Local (toi)    : http://localhost:{port}")
    print(f"R√©seau (√©quipe): http://{local_ip}:{port}")
    print("================================================\n")
    try:
        webbrowser.open(f"http://localhost:{port}")
    except Exception:
        pass
    app.run_server(host=host, port=port, debug=False)
